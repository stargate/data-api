package io.stargate.sgv2.jsonapi.exception;

import com.google.common.base.Preconditions;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.function.Consumer;

/**
 * Re-usable class for holding an object and the {@link WarningException}'s that have been generated
 * for it.
 *
 * <p>This is usually used when analysing part of a query and generating warnings for the user.
 *
 * <p>Is a {@link Consumer} of {@link WithWarnings.WarningsSink} so that it can add the warnings to
 * the task, and so multiple instances can be chained together using {@link
 * Consumer#andThen(Consumer)}
 *
 * @param <T> Type of the target object the warnings are about.
 */
public class WithWarnings<T> implements Consumer<WithWarnings.WarningsSink> {

  private final T target;
  private final List<WarningException> warnings;
  private final List<WarningException.Code> suppressedWarnings;

  public WithWarnings(
      T target, List<WarningException> warnings, List<WarningException.Code> suppressedWarnings) {
    Preconditions.checkNotNull(target, "target must not be null");
    this.target = target;
    this.warnings = warnings == null ? new ArrayList<>() : warnings;
    this.suppressedWarnings = suppressedWarnings == null ? new ArrayList<>() : suppressedWarnings;
  }

  /**
   * The target object the warnings are about.
   *
   * @return The target object.
   */
  public T target() {
    return target;
  }

  /**
   * The warnings generated for the target object.
   *
   * <p>This is a mutable, so you can add more warnings to it.
   *
   * @return The list of warnings, never null.
   */
  public List<WarningException> warnings() {
    return warnings;
  }

  /**
   * The suppressed warnings generated for the target object.
   *
   * <p>This is a mutable, so you can add more suppressed warnings to it.
   *
   * @return The list of warnings, never null.
   */
  public List<WarningException.Code> suppressedWarnings() {
    return suppressedWarnings;
  }

  /** Returns true if there are no warnings. */
  public boolean isEmpty() {
    return warnings.isEmpty();
  }

  /*
   * Construct an instance with no warnings.
   *
   * @param target the target object that has no warnings
   * @return an instance with no warnings
   */
  public static <T> WithWarnings<T> of(T target) {
    return new WithWarnings<>(target, new ArrayList<>(), null);
  }

  /*
   * Constructor an instance that suppresses the listed warnings that may be generated by other code.
   *
   * @param target the target object
   * @param suppressedWarnings the warnings to suppress
   *
   * @return an instance with suppressed warnings
   */
  public static <T> WithWarnings<T> of(T target, List<WarningException.Code> suppressedWarnings) {
    return new WithWarnings<>(target, new ArrayList<>(), suppressedWarnings);
  }

  /**
   * Constructor an instance with a single warning.
   *
   * @param target the target object that has the warning
   * @param warning the warning to add
   * @return An instance with the warning
   * @param <T> Type of the target object the warnings are about.
   */
  public static <T> WithWarnings<T> of(T target, WarningException warning) {
    Objects.requireNonNull(warning, "warning is required");
    var warnings = new ArrayList<WarningException>();
    warnings.add(warning);
    return new WithWarnings<>(target, warnings, null);
  }

  /**
   * Construct an instance with the target, and all the state from the source {@link WithWarnings}.
   *
   * @param target the target object that has the warnings
   * @param source WithWarnings to copy the warnings and supressed warnings from.
   * @return An instance with the warning
   * @param <T> Type of the target object the warnings are about.
   */
  public static <T> WithWarnings<T> of(T target, WithWarnings<?> source) {
    Objects.requireNonNull(source, "warning is required");

    return new WithWarnings<>(target, source.warnings, source.suppressedWarnings);
  }

  /**
   * Adds all the warnings to the warnings sink
   *
   * @param sink the {@link WarningsSink} to add the warnings to
   */
  @Override
  public void accept(WarningsSink sink) {
    Objects.requireNonNull(sink, "sink must not be null");
    warnings.forEach(sink::addWarning);
    suppressedWarnings.forEach(sink::addSuppressedWarning);
  }

  /**
   * Interface for a class that consumes warnings, a sink that warnings drain into.
   *
   * <p>Warnings use the {@link WarningException} class to represent the warning, so we can manage
   * them the same as a {@link APIException}. But they are not errors in the same sense, they are
   * warnings to send to the users.
   */
  public interface WarningsSink {

    /**
     * Called to add a warning to the sink
     *
     * @param warning The warning message to add, is null the implementation may throw an exception.
     */
    void addWarning(WarningException warning);

    /**
     * Called to supress a warning that may have been, or may later be, added to the sink.
     *
     * <p>The sink should support any order of suppression and adding, and suppressing a warning
     * once will supress all future warnings of that code.
     *
     * @param suppressedWarning The warning message code to add, cannot be <code>null</code>.
     */
    void addSuppressedWarning(WarningException.Code suppressedWarning);

    List<WarningException> allWarnings();

    /**
     * Gets the warnings excluding all instances of warnings that have been suppressed using {@link
     * #addSuppressedWarning(WarningException.Code)}.
     *
     * @return An unmodifiable list of warnings, never <code>null</code>
     */
    List<WarningException> warningsExcludingSuppressed();
  }
}
