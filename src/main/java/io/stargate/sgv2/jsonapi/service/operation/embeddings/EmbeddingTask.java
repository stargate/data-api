package io.stargate.sgv2.jsonapi.service.operation.embeddings;

import com.datastax.oss.driver.api.core.cql.AsyncResultSet;
import io.smallrye.mutiny.Uni;
import io.stargate.sgv2.jsonapi.api.model.command.CommandContext;
import io.stargate.sgv2.jsonapi.api.model.command.RequestTracing;
import io.stargate.sgv2.jsonapi.service.cqldriver.executor.SchemaObject;
import io.stargate.sgv2.jsonapi.service.cqldriver.executor.TableSchemaObject;
import io.stargate.sgv2.jsonapi.service.embedding.operation.EmbeddingProvider;
import io.stargate.sgv2.jsonapi.service.operation.tasks.BaseTask;
import io.stargate.sgv2.jsonapi.service.operation.tasks.TaskRetryPolicy;
import io.stargate.sgv2.jsonapi.util.PrettyPrintable;
import java.util.List;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class EmbeddingTask<SchemaT extends SchemaObject>
    extends BaseTask<
        SchemaT, EmbeddingTask.EmbeddingResultSupplier, EmbeddingTask.EmbeddingTaskResult> {

  private static final Logger LOGGER = LoggerFactory.getLogger(EmbeddingTask.class);

  private final EmbeddingProvider embeddingProvider;
  private final List<EmbeddingAction> embeddingActions;
  private final EmbeddingProvider.EmbeddingRequestType requestType;

  protected EmbeddingTask(
      int position,
      SchemaT schemaObject,
      TaskRetryPolicy retryPolicy,
      EmbeddingProvider embeddingProvider,
      List<EmbeddingAction> embeddingActions,
      EmbeddingProvider.EmbeddingRequestType requestType) {
    super(position, schemaObject, retryPolicy);

    this.embeddingProvider = embeddingProvider;
    // defensive copy - we rely on the order of this list to match the order of returned vectors
    this.embeddingActions = List.copyOf(embeddingActions);
    this.requestType = requestType;

    setStatus(TaskStatus.READY);
  }

  public static EmbeddingTaskBuilder builder(CommandContext<TableSchemaObject> commandContext) {
    return new EmbeddingTaskBuilder(commandContext);
  }

  // =================================================================================================
  // BaseTask overrides
  // =================================================================================================

  @Override
  protected EmbeddingTask.EmbeddingResultSupplier buildResultSupplier(
      CommandContext<SchemaT> commandContext) {

    var vectorizeTexts = embeddingActions.stream().map(EmbeddingAction::startEmbedding).toList();
    return new EmbeddingResultSupplier(
        commandContext,
        () ->
            embeddingProvider.vectorize(
                1, // not sure why but we always pass 1 here
                vectorizeTexts,
                commandContext.requestContext().getEmbeddingCredentials(),
                requestType),
        embeddingActions);
  }

  @Override
  protected RuntimeException maybeHandleException(
      EmbeddingResultSupplier resultSupplier, RuntimeException runtimeException) {
    return null;
  }

  /**
   * Override so we can pass the vectors through to the {@link #embeddingActions} so they can set
   * the values into the deferred {@link io.stargate.sgv2.jsonapi.service.shredding.CqlNamedValue}s.
   *
   * @param result The {@link ResultT} generated by the task, e.g. an {@link AsyncResultSet}.
   */
  @Override
  protected void onSuccess(EmbeddingTaskResult result) {

    // call to make sure status is set
    super.onSuccess(result);
  }

  // =================================================================================================
  // Implementation and internals
  // =================================================================================================

  public static class EmbeddingResultSupplier implements BaseTask.UniSupplier<EmbeddingTaskResult> {

    protected final CommandContext<?> commandContext;
    protected final BaseTask.UniSupplier<EmbeddingProvider.Response> supplier;
    protected final List<EmbeddingAction> actions;

    EmbeddingResultSupplier(
        CommandContext<?> commandContext,
        BaseTask.UniSupplier<EmbeddingProvider.Response> supplier,
        List<EmbeddingAction> actions) {
      this.commandContext = commandContext;
      this.supplier = supplier;
      this.actions = actions;
    }

    @Override
    public Uni<EmbeddingTaskResult> get() {
      // todo: handle errors from the providers
      return supplier
          .get()
          .onItem()
          .transform(rawResult -> EmbeddingTaskResult.create(commandContext, rawResult, actions));
    }
  }

  public static class EmbeddingTaskResult {

    protected final List<float[]> rawVectors;
    protected final List<EmbeddingAction> actions;

    private EmbeddingTaskResult(List<float[]> rawVectors, List<EmbeddingAction> actions) {
      this.rawVectors = rawVectors;
      this.actions = actions;
    }

    /**
     * Create a new {@link EmbeddingTaskResult} which involves passing the vectors returned from the
     * provider to the {@link EmbeddingAction}s so they can set the values into the deferred {@link
     * io.stargate.sgv2.jsonapi.service.shredding.CqlNamedValue}s.
     *
     * <p>We do this as part of building the result errors occur as part of the execute of the task
     *
     * @param providerResponse
     * @param actions
     * @return
     */
    static EmbeddingTaskResult create(
        CommandContext<?> commandContext,
        EmbeddingProvider.Response providerResponse,
        List<EmbeddingAction> actions) {

      commandContext
          .requestTracing()
          .maybeTrace(
              () ->
                  new RequestTracing.TraceMessage(
                      "EmbeddingTaskResult.create() Received embedding provider response",
                      PrettyPrintable.toString(providerResponse)));

      commandContext
          .requestTracing()
          .maybeTrace(
              () ->
                  new RequestTracing.TraceMessage(
                      "EmbeddingTaskResult.create() Processing Embedding Actions",
                      PrettyPrintable.toString(actions)));

      // defensive to make sure the order cannot change
      var vectors = List.copyOf(providerResponse.embeddings());

      // TODO: what to do about the failures in the response?
      // we rely on the response vectors having the same order we passed them in
      // if an error bubbles out of there the task pipeline will attach it to the task
      for (int i = 0; i < actions.size(); i++) {
        actions.get(i).onSuccess(vectors.get(i));
      }

      return new EmbeddingTaskResult(vectors, actions);
    }
  }
}
